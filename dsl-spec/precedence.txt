{
    4 +  let a: b =  c =  d + 2   ;
    4 + (let a: b = (c = (d + 2)));

    if a  4+5 ;
    if a (4+5);

    5 +  if (a)  b - 2  else  c + 6;
    5 + (if (a) (b - 2) else (c + 6));

     let x =  macro hi { f(x) + 5 }   ; f;
    (let x = (macro hi { f(x) + 5 } )); f;

     if (a) b;  c;
    (if (a) b); c;

    if a let x = 5;

    if 0 else 1



}

This gives the following ordering, from least to highest precedence

SCOPEBODY
0 ;
1 LET MUT
IFBODY SEARCHBODY ARGUMENT LETVALUE ASSIGNMENTVALU IFCONDITION
1 IF ELSE
4 MACRO
5 =
6 == !=
7 < <= > >=
8 + -
9 * /
10 unary -
TYPE
11 . and function callee
12 {} () IDENTIFIER NUMBER STRING REF_STRING REGEX

The number tells us what an expressionX can contain (note how bodies can jump back up)
